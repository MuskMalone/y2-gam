#version 450 core
#extension GL_ARB_compute_shader : enable
#extension GL_ARB_shader_storage_buffer_object : enable

#define EMT_TYPE_SMOKE 0
#define EMT_TYPE_FIRE 1
#define EMT_TYPE_BURST 2
#define EMT_TYPE_BURSTGRAV 3
#define EMT_TYPE_GRADUAL 4

#define EMT_SHAPE_POINT 1
#define EMT_SHAPE_LINE 2
#define EMT_SHAPE_RECT 3

struct Particle {
    vec4 col;     // 16 bytes
    vec3 pos;     // 12 bytes

    vec2 vel;     // 8 bytes
    vec2 gravity; // 8 bytes
    vec2 size;    // 8 bytes (vec2 is aligned to 8 bytes)
    float rot;    // 4 bytes
    float age;    // 4 bytes
    float lifetime; // 4 bytes
    float angvel;  // 4 bytes
    int emtIdx;
    bool alive;   // 4 bytes (bool is often aligned to 4 bytes, same as float)
    // Possibly padding here to align the structure size to a multiple of 16 bytes
};

struct Emitter {
    //vertices are stored in clockwise order;
    vec4 vertices[4]; // Each vec4 is 16 bytes, total 64 bytes
    vec4 col;         // 16 bytes (vec3 is aligned like vec4)

    vec2 gravity; // 8 bytes
    vec2 size;    // 8 bytes (vec2 is aligned to 8 bytes)
    float rot;    // 4 bytes
    float lifetime; // 4 bytes
    float angvel;  // 4 bytes
    float speed;     // 8 bytes

    float time;       // 4 bytes, but due to the vec3 above, you can expect padding here
    float frequency;  // 4 bytes

    int type;         // 4 bytes
    // 1 for point, 2 for line, 4 for rect
    int vCount;       // 4 bytes
    int preset;    // 4 bytes //alpha over lifetime etc

    bool alive;       // 4 bytes (bools are often treated as 4 bytes for alignment)
    
    // Padding might be added here to align the entire structure size
};


//they are the same size owo
layout(std430, binding=11) buffer RandIdx //the index for Rands, increments every time random() is called
{ uint randIdx; };
layout(std430, binding=12) buffer Rands //list of random floats generated by the cpu
{ float RandomFloats[]; };  
layout( std430, binding=13 ) buffer Emts
{ Emitter Emitters[]; };
layout( std430, binding=14 ) buffer Pctls
{ Particle Particles[]; };
layout(std430, binding = 15) buffer ParticleIndex {
    uint usableParticleCount;
};

// local work group is 100 large. I believe ideal local size would be GCD(num_cores, num_particles)
// More testing needed
layout( local_size_x = 1000, local_size_y = 1, local_size_z = 1 ) in;

// uniform control variables
uniform float DT;
uniform float uTimeElapsed;
//variables to store the new emitter
uniform vec4 uEmtvertices[4]; // Each vec4 is 16 bytes, total 64 bytes
uniform vec4 uEmtcol;         // 16 bytes (vec3 is aligned like vec4)

uniform vec2 uEmtgravity; // 8 bytes
uniform vec2 uEmtsize;    // 8 bytes (vec2 is aligned to 8 bytes)
uniform float uEmtrot;    // 4 bytes
uniform float uEmtlifetime; // 4 bytes
uniform float uEmtangvel;  // 4 bytes
uniform float uEmtspeed;

uniform float uEmtfrequency;  // 4 bytes
// type of emmission
//0: smoke
//1: fire
//2: burst
//3: burst with gravity
//4: gradual emission
uniform int uEmttype;         // 4 bytes
// 1 for point, 2 for line, 4 for rect
uniform int uEmtvCount;       // 4 byte
uniform int uEmtpreset;
uniform int emtTargetIdx = -1;

uniform uint bufferMaxCount;

uniform int spawnEmitter = 0;

//from -1 to 1
float random(){ //retun
    uint idx = atomicAdd(randIdx, uint(1));
    atomicCompSwap(randIdx, bufferMaxCount, uint(0));
	return RandomFloats[idx];
}

//from 0 to 1
float rand(){
    return fract(sin(dot(vec2(random()), vec2(12.9898, 78.233))) * 43758.5453);
}
float randRange(vec2 range){
    return range.x + ((range.y - range.x) * rand());
}
vec2 randDir(float startAngle, float endAngle, float magnitude){
    float angle = randRange(vec2(startAngle, endAngle));
    float s = sin(radians(angle));
    float c = cos(radians(angle));
    mat2 rotmat = mat2(
        c,-s,s,c
    );

    return (vec2(1,0) * rotmat) * magnitude;
}
vec2 randDirInRange(vec2 baseDir, float angleRange, float magnitude) {
    
    // Normalize the base direction
    vec2 normBaseDir = normalize(baseDir);

    // Calculate the angle of the base direction
    float baseAngle = atan(normBaseDir.y, normBaseDir.x);

    // Generate a random angle offset within the specified range
    float angleOffset = randRange(vec2(-angleRange / 2.0, angleRange / 2.0));

    // Calculate the final angle
    float finalAngle = baseAngle + angleOffset;

    // Create a rotation matrix
    float s = sin(finalAngle);
    float c = cos(finalAngle);
    mat2 rotMat = mat2(
        c, -s,
        s, c
    );

    // Apply the rotation and scale by magnitude
    return (vec2(1, 0) * rotMat) * magnitude;
}
void spawnParticle(Particle pctl){
    uint idx = atomicAdd(usableParticleCount, uint(1));
    atomicCompSwap(usableParticleCount, bufferMaxCount, uint(0));
    Particles[idx] = pctl;
}
void spawnParticlePoint(uint emtidx){
    spawnParticle(Particle(
        Emitters[emtidx].col, //
        vec3(Emitters[emtidx].vertices[0]),
        randDir(0, 360, Emitters[emtidx].speed), // velocity
        Emitters[emtidx].gravity,
        Emitters[emtidx].size,
        Emitters[emtidx].rot, 
        0, 
        Emitters[emtidx].lifetime, 
        Emitters[emtidx].angvel, 
        int(emtidx),
        true
    ));
}
void spawnParticleRange(uint emtidx, int vtx1, int vtx2){
    //rotate by 90 degrees to find normal;
    vec2 vec = vec2(Emitters[emtidx].vertices[vtx2] - Emitters[emtidx].vertices[vtx1]);
    vec2 point = vec2(Emitters[emtidx].vertices[vtx1]) + (rand() * vec);
    
    spawnParticle(Particle(
        Emitters[emtidx].col, //
        vec3(point, 0),
        randDir(0, 360, Emitters[emtidx].speed), // velocity
        Emitters[emtidx].gravity,
        Emitters[emtidx].size,
        Emitters[emtidx].rot, 
        0, 
        Emitters[emtidx].lifetime, 
        Emitters[emtidx].angvel, 
        int(emtidx),
        true
    ));
}

void spawnEmitterParticle(uint emtidx){
    if (Emitters[emtidx].vCount == 1){ // is point
        spawnParticlePoint(emtidx);
    }
    else if (Emitters[emtidx].vCount == 2){// is line
        spawnParticleRange(emtidx, 0, 1);
    }
    else if (Emitters[emtidx].vCount == 4){// is quad
        int randCode = int(randRange(vec2(0, 8)));
        if (randCode%2 == 1){
            int start, end;
            if (randCode == 1) {start = 0; end = 1;}
            else if (randCode == 3) {start = 0; end = 1;}
            else if (randCode == 5) {start = 0; end = 1;}
            else if (randCode == 7) {start = 0; end = 1;}


            spawnParticleRange(emtidx, start, end);
        }
        else{
            int start, end, i;
            if (randCode == 0) {start = 0; end = 90; i = 0;}
            else if (randCode == 2) {start = 90; end = 180;i = 1;}
            else if (randCode == 4) {start = 180; end = 270;i = 2;}
            else if (randCode == 8) {start = 270; end = 360;i = 3;}

            spawnParticle(Particle(
                Emitters[emtidx].col, //
                vec3(Emitters[emtidx].vertices[i]),
                randDir(start, end, Emitters[emtidx].speed), // velocity
                Emitters[emtidx].gravity,
                Emitters[emtidx].size,
                Emitters[emtidx].rot, 
                0, 
                Emitters[emtidx].lifetime, 
                Emitters[emtidx].angvel, 
                int(emtidx),
                true
            ));
        }
    }
}

void main() {
    // gid used as index into SSBO to find the particle
    // that any particular instance is controlling
    uint gid = gl_GlobalInvocationID.x;
    if (emtTargetIdx >= 0 && gid == 0){ //only one thread edits the emitter
        if (spawnEmitter == 1){ // spawn emitter
            Emitters[emtTargetIdx].vertices[0] = uEmtvertices[0]; // Each vec4 is 16 bytes, total 64 bytes
            Emitters[emtTargetIdx].vertices[1] = uEmtvertices[1]; // Each vec4 is 16 bytes, total 64 bytes
            Emitters[emtTargetIdx].vertices[2] = uEmtvertices[2]; // Each vec4 is 16 bytes, total 64 bytes
            Emitters[emtTargetIdx].vertices[3] = uEmtvertices[3]; // Each vec4 is 16 bytes, total 64 bytes

            Emitters[emtTargetIdx].col = uEmtcol;         // 16 bytes (vec3 is aligned like vec4)

            Emitters[emtTargetIdx].gravity = uEmtgravity; // 8 bytes
            Emitters[emtTargetIdx].size = uEmtsize;    // 8 bytes (vec2 is aligned to 8 bytes)
            Emitters[emtTargetIdx].rot = uEmtrot;    // 4 bytes
            Emitters[emtTargetIdx].lifetime = uEmtlifetime; // 4 bytes
            Emitters[emtTargetIdx].angvel = uEmtangvel;  // 4 bytes

            Emitters[emtTargetIdx].speed = uTimeElapsed; // just to keep uTimeElapsed around
            Emitters[emtTargetIdx].speed = uEmtspeed;

            Emitters[emtTargetIdx].time = 0.0;       // 4 bytes, but due to the vec3 above, you can expect padding here
            Emitters[emtTargetIdx].frequency = uEmtfrequency;  // 4 bytes
            Emitters[emtTargetIdx].type = uEmttype;         // 4 bytes
            Emitters[emtTargetIdx].vCount = uEmtvCount;       // 4 bytes
            Emitters[emtTargetIdx].preset = uEmtpreset;
            Emitters[emtTargetIdx].alive = true;       // 4 bytes (bools are often treated as 4 bytes for alignment)

            
        }
        
        else if (spawnEmitter == -1){ //delete emitter
            Emitters[emtTargetIdx].alive = false;       // 4 bytes (bools are often treated as 4 bytes for alignment)
        }
        else{ //edit emitter
            Emitters[emtTargetIdx].vertices[0] = uEmtvertices[0]; // Each vec4 is 16 bytes, total 64 bytes
            Emitters[emtTargetIdx].vertices[1] = uEmtvertices[1]; // Each vec4 is 16 bytes, total 64 bytes
            Emitters[emtTargetIdx].vertices[2] = uEmtvertices[2]; // Each vec4 is 16 bytes, total 64 bytes
            Emitters[emtTargetIdx].vertices[3] = uEmtvertices[3]; // Each vec4 is 16 bytes, total 64 bytes

            Emitters[emtTargetIdx].col = uEmtcol;         // 16 bytes (vec3 is aligned like vec4)

            Emitters[emtTargetIdx].gravity = uEmtgravity; // 8 bytes
            Emitters[emtTargetIdx].size = uEmtsize;    // 8 bytes (vec2 is aligned to 8 bytes)
            Emitters[emtTargetIdx].rot = uEmtrot;    // 4 bytes
            Emitters[emtTargetIdx].lifetime = uEmtlifetime; // 4 bytes
            Emitters[emtTargetIdx].angvel = uEmtangvel;  // 4 bytes
            Emitters[emtTargetIdx].speed = uEmtspeed;

            Emitters[emtTargetIdx].frequency = uEmtfrequency;  // 4 bytes
            Emitters[emtTargetIdx].type = uEmttype;         // 4 bytes
            Emitters[emtTargetIdx].vCount = uEmtvCount;       // 4 bytes
            Emitters[emtTargetIdx].preset = uEmtpreset;
        }
        return;
    }else{
        if (Emitters[gid].alive == true){
        //for each emitter
        Emitters[gid].time += DT;
        if (Emitters[gid].time >= Emitters[gid].frequency){
            Emitters[gid].time = 0.0;
            spawnEmitterParticle(gid);
        }
        }

        
        if (Particles[gid].alive == true){
            Particles[gid].age += DT;
            Particles[gid].vel += Particles[gid].gravity;
            Particles[gid].pos += vec3(Particles[gid].vel, 0) * DT;
            
            //if particles are dead
            if (Particles[gid].age >= Particles[gid].lifetime){
                Particles[gid].alive = false;
            }

        }
    
    }
}